// Class automatically generated by Dev-C++ New Class wizard
#include <iostream> 
#include "simobject.h"
#include "simmachine.h" // class's header file
#include "simevent.h"
#include "simpart.h"

#include "simqueue.h"


#include "simmodel.h"
extern simModel theModel;

// class constructor
simMachine::simMachine()
{
	// insert your code here
	state=IDLE;
	thePart=(simPart*)NULL; 
    theSource=(simObject*)NULL;
    theDestination=(simObject*)NULL;
    theObjectType=MACHINE_TYPE;
    haveToResponseEventList=false; 
}

// class destructor
simMachine::~simMachine()
{
	// insert your code here
}
bool simMachine::response(int eventTypeID)
{
    switch(eventTypeID)
    {
        case MACHINE_PULL:
            //表示拉取事件发生，
            //更改机器状态，
            //拉入零件（按优先级），
            //设置零件将要输出的类型号 
            //计算加工时间，设置Block事件发生的时间
            //向事件表添加block事件 
            //如果失败，则须响应“事件表变化事件”
            pull(); 
            break;
        case MACHINE_BLOCK:
            //表示零件加工完毕，正准备输出
            //将机器状态置为“阻”
            //计算输出零件的时刻
            //向事件表添加 push事件
            //如果失败，则须响应“事件表变化事件”
            //printf("Machine[%d] Now responce the Block event\n",InstanceNum) ; 
            block(); 
            break;
        case MACHINE_PUSH:
            //
            push();
            break;
        case EVENT_LIST_CHANGED:
            //
            break;
        default:
            break;    
    }
}
/*
#define MACHINE_PULL  100
#define MACHINE_BLOCK 101
#define MACHINE_PUSH  102
*/
bool simMachine::push()
{
    if(BLOCKED!=state){
        return false;
    } 
    else
    {
        //输出零件到“渊” 
        if(theDestination->theObjectType==QUEUE_TYPE)
        {
            simQueue *pQ=(simQueue *)theDestination;
            if(pQ->canIn())
            {
                if(pQ->GetPart(thePart))
                {
                    printf("Machine[%d]push Queue[%d]成功\n",InstanceNum,pQ->InstanceNum);
                    pQ->showContent();/////
                    state=IDLE; 
                } 
                else
                {
                    return false; 
                } 
            } 
            else
            {
                return false; 
            }
        } 
        //判断“源”是否可以拉出零件
        //设置状态
        //计算pull事件发生时刻
        //添加pull事件
        if(theSource->theObjectType==QUEUE_TYPE)
        {
            simQueue *pQ=(simQueue *)theSource;
            if(pQ->canOut())
            {
                double pullTime=theModel.theClock.nowTime;
                simEvent *pEvt=new simEvent(this,MACHINE_PULL,pullTime);
                //添加push事件//
                theModel.theEventList.AddEvent(pEvt);
                return true; 
            }
            else
            {
                haveToResponseEventList=true;
                printf("Machine[%d]计算pull失败，等待\n",InstanceNum);
                return false; 
            } 
            
        } 
        return false; 
    }
} 

bool simMachine::pull()
{
    if(IDLE==state)
    {
        if(theSource->theObjectType==QUEUE_TYPE)
        {
            simQueue *pQ=(simQueue *)theSource;
            if(pQ->canOut()){
                thePart=pQ->GivePart();
                printf("Machine[%d]PULL Queue[%d]成功\n",InstanceNum,pQ->InstanceNum);
                pQ->showContent();////
                printf("\tPart: Type=%d,Target=%d\n",thePart->PartType,thePart->ToBePartType);
            }
            //if(thePart==(simPart*)NULL)//pull失败 
            else
            { 
                haveToResponseEventList=true; 
                printf("Machine[%d]pull失败，等待\n",InstanceNum); 
                return false;
            } 
            state=BUSY;
            setPartType();
            haveToResponseEventList=false; 
            //计算block发生时刻//
            double theBlockTime=theModel.theClock.nowTime
                        + calcProcTime(thePart->PartType/*[InstanceNum]*/,thePart->ToBePartType/*[InstanceNum]*/); 
            setPartType();//设置输出类型 
            simEvent *pEvt=new simEvent(this,MACHINE_BLOCK,theBlockTime); 
            //添加block事件//
            theModel.theEventList.AddEvent(pEvt); 
            return true; 
        }
         else
         {

             if(theSource->theObjectType==MACHINE_TYPE)
             {
//                 //
//                 ;
                  printf("尚未实现此功能\n");
                  return false; 
              } 
              else{
//                 // 
                 return false;
              } 
         }
    }
    else
    {
        return false;
    }
} 

bool simMachine::block()
{
    if(BUSY!=state)
    {
        return false;
    }
    else
    {
        state=BLOCKED;
        printf("Machine[%d]Block 成功\n",InstanceNum);
        //计算输出时间
        if(theDestination->theObjectType==QUEUE_TYPE)
        {
            simQueue *pQ=(simQueue *)theDestination;
            if(pQ->canIn())
            {
                haveToResponseEventList=false;
                //计算push发生时刻//
                double thePushTime=theModel.theClock.nowTime;
                simEvent *pEvt=new simEvent(this,MACHINE_PUSH,thePushTime);
                //添加push事件//
                theModel.theEventList.AddEvent(pEvt);
                return true;
            }
            else
            {
                haveToResponseEventList=true;
                printf("Machine[%d]计算push时刻失败，等待\n",InstanceNum);
                return false;
            }
        }
        else
        {
            return false;
        } 
    } 
} 

bool simMachine::check()
{
    printf("Machine[%d]正在check\n",InstanceNum);
    if(state==BLOCKED)
    {
        //检查是否可以输出 
        return push();
    }
    else if (state==IDLE)
    {
        //检查是否可以拉入 
        return pull();
    }
    else //state==BUSY
    {
        //return block();
        return false; 
    } 
}



double simMachine::calcProcTime(int inType,int outType)
{
    //计算处理时间 
    //三个参数，机器号InstanceNum，入类型，出类型，
    //工艺之外的，设为充分长时间
    //#error "calcProcTime 还未实现" 
    //printf() 
    //std::cout<<"请在simMachine::calcProTime中设置处理时间数据"<<std::endl; 
    //float procTime(int Instance, int inType, int OutType);  
    return procTime(InstanceNum,inType,outType); 
    //return 1.3; 
} 

bool simMachine::setPartType()
{
    //check the proccess route table
    //to determine the PartType
    std::cout<<"Machine["<<InstanceNum<<"] setPartType  type="<<thePart->PartType<<"\ttarget="<<thePart->ToBePartType<<std::endl;
    int rs=queryPartType(thePart->PartType,thePart->ToBePartType,InstanceNum); 
 
    thePart->setType(rs); 
  
    return true;
}


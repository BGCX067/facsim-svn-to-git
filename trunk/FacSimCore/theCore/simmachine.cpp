// Class automatically generated by Dev-C++ New Class wizard
#include <iostream> 
#include "simobject.h"
#include "simmachine.h" // class's header file
#include "simevent.h"
#include "simpart.h"

#include "simqueue.h"


#include "simmodel.h"
extern simModel theModel;

// class constructor
simMachine::simMachine()
{
	// insert your code here
	state=IDLE;
	thePart=(simPart*)NULL; 
    theSource=(simObject*)NULL;
    theDestination=(simObject*)NULL;
    theObjectType=MACHINE_TYPE;
    haveToResponseEventList=false; 
}

// class destructor
simMachine::~simMachine()
{
	// insert your code here
}
bool simMachine::response(int eventTypeID)
{
    switch(eventTypeID)
    {
        case MACHINE_PULL:
            //±íÊ¾À­È¡ÊÂ¼þ·¢Éú£¬
            //¸ü¸Ä»úÆ÷×´Ì¬£¬
            //À­ÈëÁã¼þ£¨°´ÓÅÏÈ¼¶£©£¬
            //ÉèÖÃÁã¼þ½«ÒªÊä³öµÄÀàÐÍºÅ 
            //¼ÆËã¼Ó¹¤Ê±¼ä£¬ÉèÖÃBlockÊÂ¼þ·¢ÉúµÄÊ±¼ä
            //ÏòÊÂ¼þ±íÌí¼ÓblockÊÂ¼þ 
            //Èç¹ûÊ§°Ü£¬ÔòÐëÏìÓ¦¡°ÊÂ¼þ±í±ä»¯ÊÂ¼þ¡±
            pull(); 
            break;
        case MACHINE_BLOCK:
            //±íÊ¾Áã¼þ¼Ó¹¤Íê±Ï£¬Õý×¼±¸Êä³ö
            //½«»úÆ÷×´Ì¬ÖÃÎª¡°×è¡±
            //¼ÆËãÊä³öÁã¼þµÄÊ±¿Ì
            //ÏòÊÂ¼þ±íÌí¼Ó pushÊÂ¼þ
            //Èç¹ûÊ§°Ü£¬ÔòÐëÏìÓ¦¡°ÊÂ¼þ±í±ä»¯ÊÂ¼þ¡±
            //printf("Machine[%d] Now responce the Block event\n",InstanceNum) ; 
            block(); 
            break;
        case MACHINE_PUSH:
            //
            push();
            break;
        case EVENT_LIST_CHANGED:
            //
            break;
        default:
            break;    
    }
}
/*
#define MACHINE_PULL  100
#define MACHINE_BLOCK 101
#define MACHINE_PUSH  102
*/
bool simMachine::push()
{
    if(BLOCKED!=state){
        return false;
    } 
    else
    {
        //Êä³öÁã¼þµ½¡°Ô¨¡± 
        if(theDestination->theObjectType==QUEUE_TYPE)
        {
            simQueue *pQ=(simQueue *)theDestination;
            if(pQ->canIn())
            {
                if(pQ->GetPart(thePart))
                {
                    printf("Machine[%d]push Queue[%d]³É¹¦\n",InstanceNum,pQ->InstanceNum);
                    state=IDLE; 
                } 
                else
                {
                    return false; 
                } 
            } 
            else
            {
                return false; 
            }
        } 
        //ÅÐ¶Ï¡°Ô´¡±ÊÇ·ñ¿ÉÒÔÀ­³öÁã¼þ
        //ÉèÖÃ×´Ì¬
        //¼ÆËãpullÊÂ¼þ·¢ÉúÊ±¿Ì
        //Ìí¼ÓpullÊÂ¼þ
        if(theSource->theObjectType==QUEUE_TYPE)
        {
            simQueue *pQ=(simQueue *)theSource;
            if(pQ->canOut())
            {
                double pullTime=theModel.theClock.nowTime;
                simEvent *pEvt=new simEvent(this,MACHINE_PULL,pullTime);
                //Ìí¼ÓpushÊÂ¼þ//
                theModel.theEventList.AddEvent(pEvt);
                return true; 
            }
            else
            {
                haveToResponseEventList=true;
                printf("Machine[%d]¼ÆËãpullÊ§°Ü£¬µÈ´ý\n",InstanceNum);
                return false; 
            } 
            
        } 
        return false; 
    }
} 

bool simMachine::pull()
{
    if(IDLE==state)
    {
        if(theSource->theObjectType==QUEUE_TYPE)
        {
            simQueue *pQ=(simQueue *)theSource;
            if(pQ->canOut()){
                thePart=pQ->GivePart();
                printf("Machine[%d]PULL Queue[%d]³É¹¦\n",InstanceNum,pQ->InstanceNum);
            }
            //if(thePart==(simPart*)NULL)//pullÊ§°Ü 
            else
            { 
                haveToResponseEventList=true; 
                printf("Machine[%d]pullÊ§°Ü£¬µÈ´ý\n",InstanceNum); 
                return false;
            } 
            state=BUSY;
            haveToResponseEventList=false; 
            //¼ÆËãblock·¢ÉúÊ±¿Ì//
            double theBlockTime=theModel.theClock.nowTime
                        + calcProcTime(thePart->PartType[InstanceNum],thePart->ToBePartType[InstanceNum]); 
            simEvent *pEvt=new simEvent(this,MACHINE_BLOCK,theBlockTime); 
            //Ìí¼ÓblockÊÂ¼þ//
            theModel.theEventList.AddEvent(pEvt); 
            return true; 
        }
         else
         {

             if(theSource->theObjectType==MACHINE_TYPE)
             {
//                 //
//                 ;
                  printf("ÉÐÎ´ÊµÏÖ´Ë¹¦ÄÜ\n");
                  return false; 
              } 
              else{
//                 // 
                 return false;
              } 
         }
    }
    else
    {
        return false;
    }
} 

bool simMachine::block()
{
    if(BUSY!=state)
    {
        return false;
    }
    else
    {
        state=BLOCKED;
        printf("Machine[%d]Block ³É¹¦\n",InstanceNum);
        //¼ÆËãÊä³öÊ±¼ä
        if(theDestination->theObjectType==QUEUE_TYPE)
        {
            simQueue *pQ=(simQueue *)theDestination;
            if(pQ->canIn())
            {
                haveToResponseEventList=false;
                //¼ÆËãpush·¢ÉúÊ±¿Ì//
                double thePushTime=theModel.theClock.nowTime;
                simEvent *pEvt=new simEvent(this,MACHINE_PUSH,thePushTime);
                //Ìí¼ÓpushÊÂ¼þ//
                theModel.theEventList.AddEvent(pEvt);
                return true;
            }
            else
            {
                haveToResponseEventList=true;
                printf("Machine[%d]¼ÆËãpushÊ±¿ÌÊ§°Ü£¬µÈ´ý\n",InstanceNum);
                return false;
            }
        }
        else
        {
            return false;
        } 
    } 
} 

bool simMachine::check()
{
    //
    if(state==BLOCKED)
    {
        //¼ì²éÊÇ·ñ¿ÉÒÔÊä³ö 
        return push();
    }
    else if (state==IDLE)
    {
        //¼ì²éÊÇ·ñ¿ÉÒÔÀ­Èë 
        return pull();
    }
    else //state==BUSY
    {
        //return block();
        return false; 
    } 
}



double simMachine::calcProcTime(int inType,int outType)
{
    //¼ÆËã´¦ÀíÊ±¼ä 
    //Èý¸ö²ÎÊý£¬»úÆ÷ºÅInstanceNum£¬ÈëÀàÐÍ£¬³öÀàÐÍ£¬
    //¹¤ÒÕÖ®ÍâµÄ£¬ÉèÎª³ä·Ö³¤Ê±¼ä
    //#error "calcProcTime »¹Î´ÊµÏÖ" 
    //printf() 
    //std::cout<<"ÇëÔÚsimMachine::calcProTimeÖÐÉèÖÃ´¦ÀíÊ±¼äÊý¾Ý"<<std::endl; 
    return 1.3; 
} 



